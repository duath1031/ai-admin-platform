generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                      String                   @id @default(cuid())
  name                    String?
  email                   String?                  @unique
  emailVerified           DateTime?
  image                   String?
  phone                   String?
  credits                 Int                      @default(0)
  plan                    String                   @default("none")
  role                    Role                     @default(USER)
  marketingConsent        Boolean                  @default(false)
  lastLoginAt             DateTime?
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  accounts                Account[]
  apiLogs                 ApiLog[]
  chats                   Chat[]
  civilServiceSubmissions CivilServiceSubmission[]
  companyProfile          CompanyProfile?
  creditTransactions      CreditTransaction[]
  documents               Document[]
  documentLogs            DocumentLog[]
  payments                Payment[]
  powersOfAttorney        PowerOfAttorney[]
  rpaTasks                RpaTask[]
  sessions                Session[]
  subscriptions           Subscription[]
}

// 기업 마스터 프로필 (AI 비서의 기억 저장소)
model CompanyProfile {
  id            String    @id @default(cuid())
  userId        String    @unique
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 필수 식별 정보 (서류 자동완성용)
  companyName   String?   // 상호
  ownerName     String?   // 대표자명
  bizRegNo      String?   // 사업자등록번호 (10자리)
  corpRegNo     String?   // 법인등록번호 (선택)
  address       String?   // 주소
  bizType       String?   // 업태/종목
  foundedDate   DateTime? // 설립일

  // 부가 정보 (분석용)
  employeeCount Int       @default(0)
  capital       BigInt    @default(0)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
}

model Document {
  id        String        @id @default(cuid())
  title     String
  type      String
  content   String
  inputData String?
  fileUrl   String?
  status    String        @default("draft")
  version   Int           @default(1)
  userId    String
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  logs      DocumentLog[]
}

model DocumentLog {
  id             String    @id @default(cuid())
  documentId     String?
  documentType   String
  templateUsed   String?
  aiModel        String?
  inputContext   String?
  aiPrompt       String?
  aiResponse     String?
  generationTime Int?
  tokenCount     Int?
  fileSize       Int?
  status         String    @default("success")
  errorMessage   String?
  userId         String
  createdAt      DateTime  @default(now())
  document       Document? @relation(fields: [documentId], references: [id])
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RpaTask {
  id             String    @id @default(cuid())
  taskType       String
  targetSite     String
  targetUrl      String?
  formData       String
  fieldMappings  String?
  status         String    @default("pending")
  progress       Int       @default(0)
  startedAt      DateTime?
  completedAt    DateTime?
  executionLog   String?
  screenshotUrl  String?
  errorMessage   String?
  retryCount     Int       @default(0)
  maxRetries     Int       @default(3)
  userId         String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  authPhase      String?
  sessionCookies String?
  workerId       String?
  workerTaskId   String?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([taskType])
  @@index([workerId])
}

model ApiLog {
  id            String   @id @default(cuid())
  apiName       String
  endpoint      String
  method        String   @default("GET")
  requestParams String?
  responseCode  Int?
  responseData  String?
  dataCount     Int?
  latency       Int?
  status        String   @default("success")
  errorMessage  String?
  userId        String?
  createdAt     DateTime @default(now())
  user          User?    @relation(fields: [userId], references: [id])
}

model Chat {
  id        String    @id @default(cuid())
  title     String?
  userId    String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  Message[]
}

model Message {
  id        String   @id @default(cuid())
  role      String
  content   String
  metadata  String?
  chatId    String
  createdAt DateTime @default(now())
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

model ReviewRequest {
  id             String   @id @default(cuid())
  fileName       String
  fileUrl        String
  fileType       String
  analysisResult String?
  suggestions    String?
  status         String   @default("pending")
  userId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model PowerOfAttorney {
  id               String                   @id @default(cuid())
  delegatorName    String
  delegatorBirth   String
  delegatorPhone   String
  delegatorIdHash  String
  delegatorAddress String?
  serviceType      String
  serviceName      String
  serviceCode      String?
  delegationScope  String?
  signatureData    String
  signatureHash    String
  signedAt         DateTime
  validFrom        DateTime
  validTo          DateTime
  status           String                   @default("active")
  revokedAt        DateTime?
  revokedReason    String?
  userId           String
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  submissions      CivilServiceSubmission[]
  user             User                     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([validTo])
}

model CivilServiceSubmission {
  id                String                  @id @default(cuid())
  serviceName       String
  serviceCode       String?
  targetSite        String
  targetUrl         String?
  applicationData   String
  applicantName     String
  applicantBirth    String?
  applicantPhone    String?
  powerOfAttorneyId String?
  status            String                  @default("draft")
  progress          Int                     @default(0)
  applicationNumber String?
  receiptUrl        String?
  resultData        String?
  completedAt       DateTime?
  errorMessage      String?
  retryCount        Int                     @default(0)
  maxRetries        Int                     @default(3)
  userId            String
  creditsUsed       Int                     @default(0)
  createdAt         DateTime                @default(now())
  updatedAt         DateTime                @updatedAt
  powerOfAttorney   PowerOfAttorney?        @relation(fields: [powerOfAttorneyId], references: [id])
  user              User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  trackingLogs      SubmissionTrackingLog[]

  @@index([userId])
  @@index([status])
  @@index([applicationNumber])
}

model SubmissionTrackingLog {
  id            String                 @id @default(cuid())
  submissionId  String
  step          String
  stepOrder     Int
  status        String
  message       String?
  screenshotUrl String?
  htmlSnapshot  String?
  startedAt     DateTime?
  completedAt   DateTime?
  duration      Int?
  createdAt     DateTime               @default(now())
  submission    CivilServiceSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@index([submissionId])
  @@index([step])
}

model SubscriptionPlan {
  id                    String         @id @default(cuid())
  name                  String         @unique
  displayName           String
  price                 Int
  credits               Int
  features              String
  isActive              Boolean        @default(true)
  sortOrder             Int            @default(0)
  overageEnabled        Boolean        @default(true)
  overagePricePerCredit Int            @default(100)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  subscriptions         Subscription[]
}

model Subscription {
  id              String           @id @default(cuid())
  userId          String
  planId          String
  status          String           @default("active")
  startDate       DateTime         @default(now())
  endDate         DateTime?
  cancelledAt     DateTime?
  billingCycle    String           @default("monthly")
  nextBillingDate DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  payments        Payment[]
  plan            SubscriptionPlan @relation(fields: [planId], references: [id])
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Payment {
  id             String        @id @default(cuid())
  userId         String
  subscriptionId String?
  orderId        String        @unique
  paymentKey     String?
  amount         Int
  itemType       String
  itemName       String
  itemQuantity   Int           @default(1)
  status         String        @default("pending")
  method         String?
  requestedAt    DateTime      @default(now())
  approvedAt     DateTime?
  cancelledAt    DateTime?
  failReason     String?
  metadata       String?
  impUid         String?
  receiptUrl     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([orderId])
  @@index([status])
}

model CreditTransaction {
  id            String   @id @default(cuid())
  userId        String
  amount        Int
  balance       Int
  type          String
  description   String?
  referenceType String?
  referenceId   String?
  isOverage     Boolean  @default(false)
  overageAmount Int?
  overageCharge Int?
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([isOverage])
}

model OverageCharge {
  id              String   @id @default(cuid())
  userId          String
  billingMonth    String
  includedCredits Int
  usedCredits     Int
  overageCredits  Int
  pricePerCredit  Int
  totalCharge     Int
  status          String   @default("pending")
  paymentId       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, billingMonth])
  @@index([userId])
  @@index([status])
}

model SubmissionRequest {
  id             String    @id @default(cuid())
  type           String
  name           String
  phone          String
  email          String
  documentType   String
  description    String?
  attachmentUrls String?
  status         String    @default("pending")
  adminNote      String?
  emailSent      Boolean   @default(false)
  smsSent        Boolean   @default(false)
  kakaoSent      Boolean   @default(false)
  userId         String?
  assignedTo     String?
  processedAt    DateTime?
  completedAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([type])
  @@index([createdAt])
}

model Notification {
  id            String    @id @default(cuid())
  userId        String
  type          String
  title         String
  message       String
  channel       String
  status        String    @default("pending")
  sentAt        DateTime?
  isRead        Boolean   @default(false)
  readAt        DateTime?
  referenceType String?
  referenceId   String?
  errorMessage  String?
  createdAt     DateTime  @default(now())

  @@index([userId])
  @@index([status])
  @@index([isRead])
}

model SystemPrompt {
  id          String   @id @default(cuid())
  name        String   @unique
  displayName String
  description String?
  content     String
  isActive    Boolean  @default(true)
  isDefault   Boolean  @default(false)
  version     Int      @default(1)
  createdBy   String?
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
  @@index([isDefault])
}

model SiteSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  category    String
  value       String
  valueType   String   @default("string")
  displayName String
  description String?
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
}

model FormTemplate {
  id                  String   @id @default(cuid())
  code                String   @unique
  name                String
  category            String
  description         String?

  // 파일 저장
  originalFileUrl     String?
  originalFileType    String?
  docxStoragePath     String?
  docxStorageProvider String   @default("supabase")

  // 필드 정의 (JSON string)
  fields              String

  // 메타데이터
  gov24ServiceKey     String?
  requiredDocs        String?
  tips                String?
  outputFileName      String?

  // 상태
  status              String   @default("active")
  version             Int      @default(1)
  uploadedBy          String?

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([category])
  @@index([status])
}

model KnowledgeDocument {
  id           String           @id @default(cuid())
  fileName     String
  fileType     String
  fileUrl      String?
  fileSize     Int?
  title        String?
  category     String?
  tags         String?
  description  String?
  status       String           @default("pending")
  errorMessage String?
  totalChunks  Int              @default(0)
  totalTokens  Int?
  uploadedBy   String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  chunks       KnowledgeChunk[]

  // 영구 저장소 (The Vault) - Supabase Storage
  storagePath      String?    // Supabase Storage 경로 (knowledge/{uuid}/{filename})
  storageProvider  String     @default("supabase") // 'supabase' | 's3'

  // Gemini File API 필드 (임시 캐시 - 48시간 만료)
  geminiFileUri    String?    // Google File API에서 반환된 URI
  geminiMimeType   String?    // 파일 MIME 타입
  geminiFileName   String?    // Google 내부 파일명 (삭제용)
  geminiExpiresAt  DateTime?  // 파일 만료 시간 (48시간)
  processingMode   String     @default("gemini_file") // 'legacy_rag' | 'gemini_file'

  @@index([status])
  @@index([category])
  @@index([fileType])
  @@index([processingMode])
}

model KnowledgeChunk {
  id           String                 @id @default(cuid())
  documentId   String
  content      String
  chunkIndex   Int
  pageNumber   Int?
  sectionTitle String?
  tokenCount   Int?
  createdAt    DateTime               @default(now())
  embedding    Unsupported("vector")?
  document     KnowledgeDocument      @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([chunkIndex])
  @@index([embedding], map: "knowledge_chunk_embedding_idx")
}
